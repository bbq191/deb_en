#+TITLE: Personal GNU Emacs Config
#+AUTHOR: Vinci Xu & Kate Ma
#+DESCRIPTION: Vinci & Kate's personal Emacs config
#+OPTIONS: toc:4

** Neecessory Configes
*** Global Keybinding
**** Basic

#+begin_src emacs-lisp
  (with-no-warnings
    ;; Key Modifiers
    (setq mac-option-modifier 'meta
      mac-command-modifier 'super)
    (bind-keys ([(super a)] . mark-whole-buffer)
           ([(super c)] . kill-ring-save)
           ([(super l)] . goto-line)
           ([(super q)] . save-buffers-kill-emacs)
           ([(super s)] . save-buffer)
           ([(super v)] . yank)
           ([(super w)] . delete-frame)
           ([(super z)] . undo)))
  ;; reload init

  ;; recent file
  (bind-keys ("C-x C-r" . recentf-open-files))
  ;; zooming in/out
  (global-set-key (kbd "C-=") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
    ;; Insert new line
  
#+end_src


** Shackle
Customize popwin behavior

#+begin_src emacs-lisp
  (use-package shackle
    :ensure t
    :hook (after-init . shackle-mode)
    :custom
    (shackle-default-size 0.5)
    (shackle-default-alignment 'below)
    (shackle-rules '((magit-status-mode    :select t :inhibit-window-quit t :same t)
                     (magit-log-mode       :select t :inhibit-window-quit t :same t)
                     (vc-annotate-mode     :select t :inhibit-window-quit t :same t)
                     ("*quickrun*"         :select t :inhibit-window-quit t :same t)
                     (profiler-report-mode :select t)
                     (xwidget-webkit-mode  :select t :same t)
                     (comint-mode          :select t :align t :size 0.4)
                     (grep-mode            :select t :align t)
                     (rg-mode              :select t :align t)
                     ;; See also `help-window-select'
                     (apropos-mode         :select nil :align t :size 0.4)
                     (help-mode            :select nil :align t :size 0.4)
                     ("*Flycheck errors*"         :select t   :align t :size 10)
                     ("*Backtrace*"               :select t   :align t :size 15)
                     ("*Shell Command Output*"    :select nil :align t :size 0.4)
                     ("*Async Shell Command*"     :select nil :align t :size 0.4)
                     ("*Org-Babel Error Output*"  :select nil :align t :size 0.3)
                     ("*package update results*"  :select nil :align t :size 10)
                     ("*Process List*"            :select t   :align t :size 0.3)
                     ("*Occur*"                   :select t   :align t)
                     ("\\*eldoc\\( for \\)?.*\\*" :select nil :align t :size 15 :regexp t))))
#+end_src

** Vertico
Vertico is a minibuffer interface, that is, it changes the minibuffer looks and how you interact with it.

#+begin_src emacs-lisp
(use-package vertico
  :demand t                             ; Otherwise won't get loaded immediately
  :straight (vertico :files (:defaults "extensions/*") ; Special recipe to load extensions conveniently
                     :includes (vertico-indexed
                                vertico-flat
                                vertico-grid
                                vertico-mouse
                                vertico-quick
                                vertico-buffer
                                vertico-repeat
                                vertico-reverse
                                vertico-directory
                                vertico-multiform
                                vertico-unobtrusive))
  :general
  (:keymaps '(normal insert visual motion)
   "M-." #'vertico-repeat)
  (:keymaps 'vertico-map
   "<tab>" #'vertico-insert ; Set manually otherwise setting `vertico-quick-insert' overrides this
   "<escape>" #'minibuffer-keyboard-quit
   "?" #'minibuffer-completion-help
   "C-M-n" #'vertico-next-group
   "C-M-p" #'vertico-previous-group
   ;; Multiform toggles
   "<backspace>" #'vertico-directory-delete-char
   "C-w" #'vertico-directory-delete-word
   "C-<backspace>" #'vertico-directory-delete-word
   "RET" #'vertico-directory-enter
   "C-i" #'vertico-quick-insert
   "C-o" #'vertico-quick-exit
   "M-o" #'kb/vertico-quick-embark
   "M-G" #'vertico-multiform-grid
   "M-F" #'vertico-multiform-flat
   "M-R" #'vertico-multiform-reverse
   "M-U" #'vertico-multiform-unobtrusive
   "C-l" #'kb/vertico-multiform-flat-toggle)
  :hook ((rfn-eshadow-update-overlay . vertico-directory-tidy) ; Clean up file path when typing
         (minibuffer-setup . vertico-repeat-save)) ; Make sure vertico state is saved
  :custom
  (vertico-count 13)
  (vertico-resize t)
  (vertico-cycle nil)
  ;; Extensions
  (vertico-grid-separator "       ")
  (vertico-grid-lookahead 50)
  (vertico-buffer-display-action '(display-buffer-reuse-window))
  (vertico-multiform-categories
   '((file reverse)
     (consult-grep buffer)
     (consult-location)
     (imenu buffer)
     (library reverse indexed)
     (org-roam-node reverse indexed)
     (t reverse)))
  (vertico-multiform-commands
   '(("flyspell-correct-*" grid reverse)
     (org-refile grid reverse indexed)
     (consult-yank-pop indexed)
     (consult-flycheck)
     (consult-lsp-diagnostics)))
  :init
  (defun kb/vertico-multiform-flat-toggle ()
    "Toggle between flat and reverse."
    (interactive)
    (vertico-multiform--display-toggle 'vertico-flat-mode)
    (if vertico-flat-mode
        (vertico-multiform--temporary-mode 'vertico-reverse-mode -1)
      (vertico-multiform--temporary-mode 'vertico-reverse-mode 1)))
  (defun kb/vertico-quick-embark (&optional arg)
    "Embark on candidate using quick keys."
    (interactive)
    (when (vertico-quick-jump)
      (embark-act arg)))

  ;; Workaround for problem with `tramp' hostname completions. This overrides
  ;; the completion style specifically for remote files! See
  ;; https://github.com/minad/vertico#tramp-hostname-completion
  (defun kb/basic-remote-try-completion (string table pred point)
    (and (vertico--remote-p string)
         (completion-basic-try-completion string table pred point)))
  (defun kb/basic-remote-all-completions (string table pred point)
    (and (vertico--remote-p string)
         (completion-basic-all-completions string table pred point)))
  (add-to-list 'completion-styles-alist
               '(basic-remote           ; Name of `completion-style'
                 kb/basic-remote-try-completion kb/basic-remote-all-completions nil))
  :config
  (vertico-mode)
  ;; Extensions
  (vertico-multiform-mode)

  ;; Prefix the current candidate with “» ”. From
  ;; https://github.com/minad/vertico/wiki#prefix-current-candidate-with-arrow
  (advice-add #'vertico--format-candidate :around
                                          (lambda (orig cand prefix suffix index _start)
                                            (setq cand (funcall orig cand prefix suffix index _start))
                                            (concat
                                             (if (= vertico--index index)
                                                 (propertize "» " 'face 'vertico-current)
                                               "  ")
                                             cand))))
#+end_src

** Embark with Consult

#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :bind (:map minibuffer-local-map
           ("M-o"     . embark-act)
           ("C-c C-c" . embark-export)
           ("C-c C-o" . embark-collect)))

  (use-package consult
    :ensure t
    :bind (([remap imenu]                  . consult-imenu)
           ([remap goto-line]              . consult-goto-line)
           ([remap bookmark-jump]          . consult-bookmark)
           ([remap recentf-open-files]     . consult-recent-file)
           ([remap repeat-complex-command] . consult-complex-command)
           ([remap jump-to-register]       . consult-register-load)
           ([remap point-to-register]      . consult-register-store))
    :config
    (with-no-warnings
      (consult-customize consult-ripgrep consult-git-grep consult-grep
                         consult-bookmark
                         consult-recent-file
                         consult-buffer
                         :preview-key nil))

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)
    :custom
    (consult-fontify-preserve nil)
    (consult-async-min-input 2)
    (consult-async-refresh-delay 0.15)
    (consult-async-input-throttle 0.2)
    (consult-async-input-debounce 0.1))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :ensure t
    :after embark consult)
#+end_src

** Orderless
Orderless is an alternative and powerful completion style, that is, it is an alternative to Emacs’s basic candidate-filtering capacities.

#+begin_src emacs-lisp
  (use-package orderless
  :custom
  (completion-styles '(orderless))
  (completion-category-defaults nil)    ; I want to be in control!
  (completion-category-overrides
   '((file (styles basic-remote ; For `tramp' hostname completion with `vertico'
                   orderless))))

  (orderless-component-separator 'orderless-escapable-split-on-space)
  (orderless-matching-styles
   '(orderless-literal
     orderless-prefixes
     orderless-initialism
     orderless-regexp
     ;; orderless-flex
     ;; orderless-strict-leading-initialism
     ;; orderless-strict-initialism
     ;; orderless-strict-full-initialism
     ;; orderless-without-literal          ; Recommended for dispatches instead
     ))
  (orderless-style-dispatchers
   '(prot-orderless-literal-dispatcher
     prot-orderless-strict-initialism-dispatcher
     prot-orderless-flex-dispatcher))
  :init
  (defun orderless--strict-*-initialism (component &optional anchored)
    "Match a COMPONENT as a strict initialism, optionally ANCHORED.
The characters in COMPONENT must occur in the candidate in that
order at the beginning of subsequent words comprised of letters.
Only non-letters can be in between the words that start with the
initials.

If ANCHORED is `start' require that the first initial appear in
the first word of the candidate.  If ANCHORED is `both' require
that the first and last initials appear in the first and last
words of the candidate, respectively."
    (orderless--separated-by
        '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)))
      (cl-loop for char across component collect `(seq word-start ,char))
      (when anchored '(seq (group buffer-start) (zero-or-more (not alpha))))
      (when (eq anchored 'both)
        '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)) eol))))

  (defun orderless-strict-initialism (component)
    "Match a COMPONENT as a strict initialism.
This means the characters in COMPONENT must occur in the
candidate in that order at the beginning of subsequent words
comprised of letters.  Only non-letters can be in between the
words that start with the initials."
    (orderless--strict-*-initialism component))

  (defun prot-orderless-literal-dispatcher (pattern _index _total)
    "Literal style dispatcher using the equals sign as a suffix.
It matches PATTERN _INDEX and _TOTAL according to how Orderless
parses its input."
    (when (string-suffix-p "=" pattern)
      `(orderless-literal . ,(substring pattern 0 -1))))

  (defun prot-orderless-strict-initialism-dispatcher (pattern _index _total)
    "Leading initialism  dispatcher using the comma suffix.
It matches PATTERN _INDEX and _TOTAL according to how Orderless
parses its input."
    (when (string-suffix-p "," pattern)
      `(orderless-strict-initialism . ,(substring pattern 0 -1))))

  (defun prot-orderless-flex-dispatcher (pattern _index _total)
    "Flex  dispatcher using the tilde suffix.
It matches PATTERN _INDEX and _TOTAL according to how Orderless
parses its input."
    (when (string-suffix-p "." pattern)
      `(orderless-flex . ,(substring pattern 0 -1)))))
#+end_src

** Corfu
Corfu is a text completion (e.g. completion-at-point, company-mode) package.

#+begin_src emacs-lisp
  (use-package corfu
    :straight (:files (:defaults "extensions/*"))
    :hook ((lsp-completion-mode . kb/corfu-setup-lsp) ; Use corfu for lsp completion
           (kb/corfu-setup-lsp . corfu-popupinfo-mode))
    :general
    (:keymaps 'corfu-map
     :states 'insert
     "C-n" #'corfu-next
     "C-p" #'corfu-previous
     "<escape>" #'corfu-quit
     "<return>" #'corfu-insert
     "M-s-SPC" #'corfu-insert-separator
     ;; "SPC" #'corfu-insert-separator ; Use when `corfu-quit-at-boundary' is non-nil
     "M-d" #'corfu-show-documentation
     "C-g" #'corfu-quit
     "M-l" #'corfu-show-location)
    :custom
    ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
    ;; want to perform completion
    (tab-always-indent 'complete)
    (completion-cycle-threshold nil)      ; Always show candidates in menu

    (corfu-auto nil)
    (corfu-auto-prefix 2)
    (corfu-auto-delay 0.25)

    (corfu-min-width 80)
    (corfu-max-width corfu-min-width)     ; Always have the same width
    (corfu-count 14)
    (corfu-scroll-margin 4)
    (corfu-cycle nil)

    ;; `nil' means to ignore `corfu-separator' behavior, that is, use the older
    ;; `corfu-quit-at-boundary' = nil behavior. Set this to separator if using
    ;; `corfu-auto' = `t' workflow (in that case, make sure you also set up
    ;; `corfu-separator' and a keybind for `corfu-insert-separator', which my
    ;; configuration already has pre-prepared). Necessary for manual corfu usage with
    ;; orderless, otherwise first component is ignored, unless `corfu-separator'
    ;; is inserted.
    (corfu-quit-at-boundary nil)
    (corfu-separator ?\s)            ; Use space
    (corfu-quit-no-match 'separator) ; Don't quit if there is `corfu-separator' inserted
    (corfu-preview-current 'insert)  ; Preview first candidate. Insert on input if only one
    (corfu-preselect-first t)        ; Preselect first candidate?

    ;; Other
    (corfu-echo-documentation nil)        ; Already use corfu-doc
    (lsp-completion-provider :none)       ; Use corfu instead for lsp completions
    :init
    (global-corfu-mode)
    :config
    ;; NOTE 2022-03-01: This allows for a more evil-esque way to have
    ;; `corfu-insert-separator' work with space in insert mode without resorting to
    ;; overriding keybindings with `general-override-mode-map'. See
    ;; https://github.com/minad/corfu/issues/12#issuecomment-869037519
    ;; Alternatively, add advice without `general.el':
    ;; (advice-add 'corfu--setup :after 'evil-normalize-keymaps)
    ;; (advice-add 'corfu--teardown :after 'evil-normalize-keymaps)
    ;; (general-add-advice '(corfu--setup corfu--teardown) :after 'evil-normalize-keymaps)
    ;; (evil-make-overriding-map corfu-map)

    ;; Enable Corfu more generally for every minibuffer, as long as no other
    ;; completion UI is active. If you use Mct or Vertico as your main minibuffer
    ;; completion UI. From
    ;; https://github.com/minad/corfu#completing-with-corfu-in-the-minibuffer
    (defun corfu-enable-always-in-minibuffer ()
      "Enable Corfu in the minibuffer if Vertico/Mct are not active."
      (unless (or (bound-and-true-p mct--active) ; Useful if I ever use MCT
                  (bound-and-true-p vertico--input))
        (setq-local corfu-auto nil)       ; Ensure auto completion is disabled
        (corfu-mode 1)))
    (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)

    ;; Setup lsp to use corfu for lsp completion
    (defun kb/corfu-setup-lsp ()
      "Use orderless completion style with lsp-capf instead of the
  default lsp-passthrough."
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
            '(orderless))))
#+end_src

*** Kind icon
Kind-icon is essentially company-box-icons for corfu. It adds icons to the left margin of the corfu popup that represent the ‘function’ (e.g. variable, method, file) of that candidate.

#+begin_src emacs-lisp
  (use-package kind-icon
    :after corfu
    :custom
    (kind-icon-use-icons t)
    (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face background
    (kind-icon-blend-background nil)  ; Use midpoint color between foreground and background colors ("blended")?
    (kind-icon-blend-frac 0.08)

    ;; NOTE 2022-02-05: `kind-icon' depends `svg-lib' which creates a cache
    ;; directory that defaults to the `user-emacs-directory'. Here, I change that
    ;; directory to a location appropriate to `no-littering' conventions, a
    ;; package which moves directories of other packages to sane locations.
    (svg-lib-icons-dir (no-littering-expand-var-file-name "svg-lib/cache/")) ; Change cache dir
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter) ; Enable `kind-icon'

    ;; Add hook to reset cache so the icon colors match my theme
    ;; NOTE 2022-02-05: This is a hook which resets the cache whenever I switch
    ;; the theme using my custom defined command for switching themes. If I don't
    ;; do this, then the backgound color will remain the same, meaning it will not
    ;; match the background color corresponding to the current theme. Important
    ;; since I have a light theme and dark theme I switch between. This has no
    ;; function unless you use something similar
    (add-hook 'kb/themes-hooks #'(lambda () (interactive) (kind-icon-reset-cache))))
#+end_src

*** Cape
Cape is to corfu as company-backends are to company

#+begin_src emacs-lisp
  (use-package cape
    :hook ((emacs-lisp-mode .  kb/cape-capf-setup-elisp)
           (lsp-completion-mode . kb/cape-capf-setup-lsp)
           (org-mode . kb/cape-capf-setup-org)
           (eshell-mode . kb/cape-capf-setup-eshell)
           (git-commit-mode . kb/cape-capf-setup-git-commit)
           (sh-mode . kb/cape-capf-setup-sh))
    :general (:prefix "M-p"               ; Particular completion function
                      "p" 'completion-at-point
                      "t" 'complete-tag           ; etags
                      "d" 'cape-dabbrev           ; or dabbrev-completion
                      "f" 'cape-file
                      "k" 'cape-keyword
                      "s" 'cape-lisp-symbol
                      "a" 'cape-abbrev
                      "i" 'cape-ispell
                      "l" 'cape-line
                      "w" 'cape-dict
                      "\\"'cape-tex
                      "_" 'cape-tex
                      "^" 'cape-tex
                      "&" 'cape-sgml
                      "r" 'cape-rfc1345)
    :custom (cape-dabbrev-min-length 3)
    :init
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'.  The order of the functions matters, the
    ;; first function returning a result wins.  Note that the list of buffer-local
    ;; completion functions takes precedence over the global list.
    ;; Elisp
    (defun kb/cape-capf-ignore-keywords-elisp (cand)
      "Ignore keywords with forms that begin with \":\" (e.g.
  :history)."
      (or (not (keywordp cand))
          (eq (char-after (car completion-in-region--data)) ?:)))
    (defun kb/cape-capf-setup-elisp ()
      "Replace the default `elisp-completion-at-point'
  completion-at-point-function. Doing it this way will prevent
  disrupting the addition of other capfs (e.g. merely setting the
  variable entirely, or adding to list).

  Additionally, add `cape-file' as early as possible to the list."
      (setf (elt (cl-member 'elisp-completion-at-point completion-at-point-functions) 0)
            #'elisp-completion-at-point)
      (add-to-list 'completion-at-point-functions #'cape-lisp-symbol)
      ;; I prefer this being early/first in the list
      (add-to-list 'completion-at-point-functions #'cape-file)
      (require 'company-yasnippet)
      (add-to-list 'completion-at-point-functions (cape-company-to-capf #'company-yasnippet)))

    ;; LSP
    (defun kb/cape-capf-setup-lsp ()
      "Replace the default `lsp-completion-at-point' with its
  `cape-capf-buster' version. Also add `cape-file' and
  `company-yasnippet' backends."
      (setf (elt (cl-member 'lsp-completion-at-point completion-at-point-functions) 0)
            (cape-capf-buster #'lsp-completion-at-point))
      ;; TODO 2022-02-28: Maybe use `cape-wrap-predicate' to have candidates
      ;; listed when I want?
      (add-to-list 'completion-at-point-functions (cape-company-to-capf #'company-yasnippet))
      (add-to-list 'completion-at-point-functions #'cape-dabbrev t))

    ;; Org
    (defun kb/cape-capf-setup-org ()
      (require 'org-roam)
      (if (org-roam-file-p)
          (org-roam--register-completion-functions-h)
        (let (result)
          (dolist (element (list
                            (cape-capf-super #'cape-ispell #'cape-dabbrev)
                            (cape-company-to-capf #'company-yasnippet))
                           result)
            (add-to-list 'completion-at-point-functions element)))))

    ;; Eshell
    (defun kb/cape-capf-setup-eshell ()
      (let ((result))
        (dolist (element '(pcomplete-completions-at-point cape-file) result)
          (add-to-list 'completion-at-point-functions element))))

    ;; Git-commit
    (defun kb/cape-capf-setup-git-commit ()
      (general-define-key
       :keymaps 'local
       :states 'insert
       "<tab>" 'completion-at-point)      ; Keybinding for `completion-at-point'
      (let ((result))
        (dolist (element '(cape-dabbrev cape-symbol) result)
          (add-to-list 'completion-at-point-functions element))))

    ;; Sh
    (defun kb/cape-capf-setup-sh ()
      (require 'company-shell)
      (add-to-list 'completion-at-point-functions (cape-company-to-capf #'company-shell)))
      :config
      ;; For pcomplete. For now these two advices are strongly recommended to
      ;; achieve a sane Eshell experience. See
      ;; https://github.com/minad/corfu#completing-with-corfu-in-the-shell-or-eshell
      ;; Silence the pcomplete capf, no errors or messages!
      (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)
      ;; Ensure that pcomplete does not write to the buffer and behaves as a pure
      ;; `completion-at-point-function'.
      (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify))
#+end_src

*** Projectile
Projectile is a project interaction library for Emacs

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :hook (after-init . projectile-mode)
    :bind (:map projectile-mode-map
           ("C-c p" . projectile-command-map))
    :config
    (dolist (dir '("bazel-bin"
                   "bazel-out"
                   "bazel-testlogs"))
      (add-to-list 'projectile-globally-ignored-directories dir))
    :custom
    (projectile-use-git-grep t)
    (projectile-indexing-method 'alien)
    (projectile-kill-buffers-filter 'kill-only-files)
    ;; Ignore uninteresting files. It has no effect when using alien mode.
    (projectile-globally-ignored-files '("TAGS" "tags" ".DS_Store"))
    (projectile-globally-ignored-file-suffixes '(".elc" ".pyc" ".o" ".swp" ".so" ".a"))
    (projectile-ignored-projects `("~/"
                                   "/tmp/"
                                   "/private/tmp/"
                                   ,package-user-dir)))
#+END_SRC


* Developer
** LSP
*** Lsp Mode

#+begin_src emacs-lisp
  ;; lsp-mode
  (use-package lsp-mode
    :ensure t
    :hook (prog-mode . lsp-deferred)
    :bind (:map lsp-mode-map
                ("C-c f" . lsp-format-region)
                ("C-c d" . lsp-describe-thing-at-point)
                ("C-c a" . lsp-execute-code-action)
                ("C-c r" . lsp-rename))
    :config (with-no-warnings
            (lsp-enable-which-key-integration t))
    :custom
    (lsp-keymap-prefix "C-c l")
    (lsp-enable-links nil)                    ;; no clickable links
    (lsp-enable-folding nil)                  ;; use `hideshow' instead
    (lsp-enable-snippet t)                    ;; no snippets, it requires `yasnippet'
    (lsp-enable-file-watchers nil)            ;; performance matters
    (lsp-enable-text-document-color nil)      ;; as above
    (lsp-enable-symbol-highlighting t)        ;; as above
    (lsp-enable-on-type-formatting nil)       ;; as above
    (lsp-semantic-tokens-enable nil)          ;; optional
    (lsp-semantic-tokens-apply-modifiers nil) ;; don't override token faces
    (lsp-headerline-breadcrumb-enable nil)    ;; keep headline clean
    (lsp-modeline-code-actions-enable nil)    ;; keep modeline clean
    (lsp-modeline-diagnostics-enable t)       ;; as above
    (lsp-log-io nil)                          ;; debug only
    (lsp-auto-guess-root t)                   ;; Yes, I'm using projectile
    (lsp-completion-provider :none)           ;; don't add `company-capf' to `company-backends'
    (lsp-keep-workspace-alive nil)            ;; auto kill lsp server
    (lsp-eldoc-enable-hover nil)              ;; disable eldoc hover
    ;; 指定 flycheck 使用 clippy
    ;; (lsp-rust-analyzer-cargo-watch-command "clippy")
    (lsp-rust-analyzer-server-display-inlay-hints t)
    (lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial")
    (lsp-rust-analyzer-display-chaining-hints t)
    (lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil)
    (lsp-rust-analyzer-display-closure-return-type-hints t)
    (lsp-rust-analyzer-display-parameter-hints nil)
    (lsp-rust-analyzer-display-reborrow-hints nil)

    :config
    (add-hook 'lsp-mode-hook 'lsp-ui-mode))
#+end_src

*** Eglot

#+begin_src emacs-lisp
  (use-package eglot
    :disabled
    :hook (prog-mode . eglot-ensure)
    :bind (:map eglot-mode-map
                ("C-c f" . eglot-format)
                ("C-c d" . eldoc-doc-buffer)
                ("C-c a" . eglot-code-actions)
                ("C-c r" . eglot-rename)
                ("C-c l" . eglot-command-map))
    :config
    (defvar-keymap eglot-command-map
      :prefix 'eglot-command-map
      ;; workspaces
      "w q" #'eglot-shutdown
      "w r" #'eglot-reconnect
      "w s" #'eglot
      "w d" #'eglot-show-workspace-configuration

      ;; formatting
      "= =" #'eglot-format-buffer
      "= r" #'eglot-format

      ;; goto
      "g a" #'xref-find-apropos
      "g d" #'eglot-find-declaration
      "g g" #'xref-find-definitions
      "g i" #'eglot-find-implementation
      "g r" #'xref-find-references
      "g t" #'eglot-find-typeDefinition

      ;; actions
      "a q" #'eglot-code-action-quickfix
      "a r" #'eglot-code-action-rewrite
      "a i" #'eglot-code-action-inline
      "a e" #'eglot-code-action-extract
      "a o" #'eglot-code-action-organize-imports)
    :custom
    (eglot-sync-connect 0)
    (eglot-autoshutdown t)
    (eglot-extend-to-xref t)
    (eglot-events-buffer-size 0)
    (eglot-ignored-server-capabilities '(:documentLinkProvider
                                         :documentOnTypeFormattingProvider)))
#+end_src

*** LSP Ui
#+begin_src emacs-lisp
  (use-package lsp-ui
    :ensure
    :commands lsp-ui-mode
    :custom (lsp-ui-peek-always-show t)
            (lsp-ui-sideline-show-hover nil)
            (lsp-ui-sideline-enable nil)
            (lsp-ui-doc-enable nil))
#+end_src

** Language
*** Rust
**** Rustic
rustic = basic rust-mode + additions

#+begin_src emacs-lisp
  (use-package rustic
    :ensure
    :bind (:map rustic-mode-map
                ("M-j" . lsp-ui-imenu)
                ("M-?" . lsp-find-references)
                ("C-c C-c l" . flycheck-list-errors)
                ("C-c C-c a" . lsp-execute-code-action)
                ("C-c C-c r" . lsp-rename)
                ("C-c C-c q" . lsp-workspace-restart)
                ("C-c C-c Q" . lsp-workspace-shutdown)
                ("C-c C-c s" . lsp-rust-analyzer-status)
                ("C-c C-c e" . lsp-rust-analyzer-expand-macro)
                ("C-c C-c d" . dap-hydra)
                ("C-c C-c h" . lsp-ui-doc-glance))
    :config (push 'rustic-clippy flycheck-checkers)
            (setq rustic-format-on-save t)
    ;; uncomment for less flashiness
    ;; (setq lsp-eldoc-hook nil)
    ;; (setq lsp-enable-symbol-highlighting nil)
    ;; (setq lsp-signature-auto-activate nil)
    :custom (rustic-lsp-setup-p nil)
            (rustic-analyzer-command '("~/.local/share/cargo/bin/rust-analyzer"))
            (rustic-flycheck-clippy-params "--message-format=json -Zunstable-options")
            (rustic-rustfmt-args "+nightly")
            (rustic-rustfmt-config-alist '((hard_tabs . t) (skip_children . nil)))
    
    (add-hook 'rustic-mode-hook 'kv/rustic-mode-hook))

  (defun kv/rustic-mode-hook ()
    ;; so that run C-c C-c C-r works without having to confirm, but don't try to
    ;; save rust buffers that are not file visiting. Once
    ;; https://github.com/brotzeit/rustic/issues/253 has been resolved this should
    ;; no longer be necessary.
    (when buffer-file-name
      (setq-local buffer-save-without-query t))
    (add-hook 'before-save-hook 'lsp-format-buffer nil t))
#+end_src

**** Rust Playground
Create / cleanup rust scratch projects quickly

#+begin_src emacs-lisp
  (use-package rust-playground :ensure)
#+end_src

**** Toml
Cargo.toml and other config files
#+begin_src emacs-lisp
  (use-package toml-mode :ensure)
#+end_src

*** C/C++

#+begin_src emacs-lisp
#+end_src

*** Yaml

#+begin_src emacs-lisp
  ;; Config files mode
  (use-package yaml-mode
    :ensure t
    :mode ("\\.ya?ml\\'" . yaml-mode))
#+end_src

** Flycheck

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :hook (prog-mode . flycheck-mode)
    :custom
    (flycheck-temp-prefix ".flycheck")
    (flycheck-check-syntax-automatically '(save mode-enabled))
    (flycheck-emacs-lisp-load-path 'inherit)
    (flycheck-indication-mode 'right-fringe))
#+end_src

*** Flycheck Extensions

#+begin_src emacs-lisp
  ;; inline
  (use-package flycheck-inline)
  (with-eval-after-load 'flycheck
    (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))
  ;; for rust
  (use-package flycheck-rust
    :init
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+end_src

** Magit

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :hook (git-commit-setup . git-commit-turn-on-flyspell)
    :bind (("C-x g"   . magit-status)
           ("C-x M-g" . magit-dispatch)
           ("C-c M-g" . magit-file-dispatch))
    :custom
    (magit-diff-refine-hunk t)
    (magit-diff-paint-whitespace nil)
    (magit-ediff-dwim-show-on-hunks t))

  ;; NOTE: `diff-hl' depends on `vc'
  (use-package vc
    :ensure nil
    :custom
    (vc-follow-symlinks t)
    (vc-allow-async-revert t)
    (vc-handled-backends '(Git)))

  ;; Highlight uncommitted changes using VC
  (use-package diff-hl
    :ensure t
    :hook ((after-init         . global-diff-hl-mode)
           (dired-mode         . diff-hl-dired-mode-unless-remote)
           (magit-pre-refresh  . diff-hl-magit-pre-refresh)
           (magit-post-refresh . diff-hl-magit-post-refresh))
    :config
    ;; When Emacs runs in terminal, show the indicators in margin instead.
    (unless (display-graphic-p)
      (diff-hl-margin-mode)))

  ;; Visual diff interface
  (use-package ediff
    :ensure nil
    ;; Restore window config after quitting ediff
    :hook ((ediff-before-setup . ediff-save-window-conf)
           (ediff-quit         . ediff-restore-window-conf))
    :config
    (defvar local-ediff-saved-window-conf nil)

    (defun ediff-save-window-conf ()
      (setq local-ediff-saved-window-conf (current-window-configuration)))

    (defun ediff-restore-window-conf ()
      (when (window-configuration-p local-ediff-saved-window-conf)
        (set-window-configuration local-ediff-saved-window-conf)))
    :custom
    (ediff-highlight-all-diffs t)
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    (ediff-split-window-function 'split-window-horizontally)
    (ediff-merge-split-window-function 'split-window-horizontally))

  ;; Setup gitignore mode
  (use-package conf-mode
    :ensure nil
    :mode (("\\.gitignore\\'"     . conf-unix-mode)
           ("\\.gitconfig\\'"     . conf-unix-mode)
           ("\\.gitattributes\\'" . conf-unix-mode)))
#+end_src




* Which Key

#+begin_src emacs-lisp
  (use-package which-key
    :init
      (which-key-mode 1)
    :diminish
    :config
    (setq which-key-side-window-location 'bottom
        which-key-sort-order #'which-key-key-order-alpha
        which-key-allow-imprecise-window-fit nil
        which-key-sort-uppercase-first nil
        which-key-add-column-padding 1
        which-key-max-display-columns nil
        which-key-min-display-lines 6
        which-key-side-window-slot -10
        which-key-side-window-max-height 0.25
        which-key-idle-delay 0.8
        which-key-max-description-length 25
        which-key-allow-imprecise-window-fit nil
        which-key-separator " → " ))
#+end_src


