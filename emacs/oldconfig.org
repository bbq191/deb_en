#+TITLE: Personal GNU Emacs Config
#+AUTHOR: Vinci Xu & Kate Ma
#+DESCRIPTION: Vinci & Kate's personal Emacs config
#+OPTIONS: toc:4

** Neecessory Configes
*** Global Keybinding
**** Basic

#+begin_src emacs-lisp
  (with-no-warnings
    ;; Key Modifiers
    (setq mac-option-modifier 'meta
      mac-command-modifier 'super)
    (bind-keys ([(super a)] . mark-whole-buffer)
           ([(super c)] . kill-ring-save)
           ([(super l)] . goto-line)
           ([(super q)] . save-buffers-kill-emacs)
           ([(super s)] . save-buffer)
           ([(super v)] . yank)
           ([(super w)] . delete-frame)
           ([(super z)] . undo)))
  ;; reload init

  ;; recent file
  (bind-keys ("C-x C-r" . recentf-open-files))
  ;; zooming in/out
  (global-set-key (kbd "C-=") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
    ;; Insert new line
  
#+end_src


** Shackle
Customize popwin behavior

#+begin_src emacs-lisp
  (use-package shackle
    :ensure t
    :hook (after-init . shackle-mode)
    :custom
    (shackle-default-size 0.5)
    (shackle-default-alignment 'below)
    (shackle-rules '((magit-status-mode    :select t :inhibit-window-quit t :same t)
                     (magit-log-mode       :select t :inhibit-window-quit t :same t)
                     (vc-annotate-mode     :select t :inhibit-window-quit t :same t)
                     ("*quickrun*"         :select t :inhibit-window-quit t :same t)
                     (profiler-report-mode :select t)
                     (xwidget-webkit-mode  :select t :same t)
                     (comint-mode          :select t :align t :size 0.4)
                     (grep-mode            :select t :align t)
                     (rg-mode              :select t :align t)
                     ;; See also `help-window-select'
                     (apropos-mode         :select nil :align t :size 0.4)
                     (help-mode            :select nil :align t :size 0.4)
                     ("*Flycheck errors*"         :select t   :align t :size 10)
                     ("*Backtrace*"               :select t   :align t :size 15)
                     ("*Shell Command Output*"    :select nil :align t :size 0.4)
                     ("*Async Shell Command*"     :select nil :align t :size 0.4)
                     ("*Org-Babel Error Output*"  :select nil :align t :size 0.3)
                     ("*package update results*"  :select nil :align t :size 10)
                     ("*Process List*"            :select t   :align t :size 0.3)
                     ("*Occur*"                   :select t   :align t)
                     ("\\*eldoc\\( for \\)?.*\\*" :select nil :align t :size 15 :regexp t))))
#+end_src

** Vertico
Vertico is a minibuffer interface, that is, it changes the minibuffer looks and how you interact with it.

#+begin_src emacs-lisp
(use-package vertico
  :demand t                             ; Otherwise won't get loaded immediately
  :straight (vertico :files (:defaults "extensions/*") ; Special recipe to load extensions conveniently
                     :includes (vertico-indexed
                                vertico-flat
                                vertico-grid
                                vertico-mouse
                                vertico-quick
                                vertico-buffer
                                vertico-repeat
                                vertico-reverse
                                vertico-directory
                                vertico-multiform
                                vertico-unobtrusive))
  :general
  (:keymaps '(normal insert visual motion)
   "M-." #'vertico-repeat)
  (:keymaps 'vertico-map
   "<tab>" #'vertico-insert ; Set manually otherwise setting `vertico-quick-insert' overrides this
   "<escape>" #'minibuffer-keyboard-quit
   "?" #'minibuffer-completion-help
   "C-M-n" #'vertico-next-group
   "C-M-p" #'vertico-previous-group
   ;; Multiform toggles
   "<backspace>" #'vertico-directory-delete-char
   "C-w" #'vertico-directory-delete-word
   "C-<backspace>" #'vertico-directory-delete-word
   "RET" #'vertico-directory-enter
   "C-i" #'vertico-quick-insert
   "C-o" #'vertico-quick-exit
   "M-o" #'kb/vertico-quick-embark
   "M-G" #'vertico-multiform-grid
   "M-F" #'vertico-multiform-flat
   "M-R" #'vertico-multiform-reverse
   "M-U" #'vertico-multiform-unobtrusive
   "C-l" #'kb/vertico-multiform-flat-toggle)
  :hook ((rfn-eshadow-update-overlay . vertico-directory-tidy) ; Clean up file path when typing
         (minibuffer-setup . vertico-repeat-save)) ; Make sure vertico state is saved
  :custom
  (vertico-count 13)
  (vertico-resize t)
  (vertico-cycle nil)
  ;; Extensions
  (vertico-grid-separator "       ")
  (vertico-grid-lookahead 50)
  (vertico-buffer-display-action '(display-buffer-reuse-window))
  (vertico-multiform-categories
   '((file reverse)
     (consult-grep buffer)
     (consult-location)
     (imenu buffer)
     (library reverse indexed)
     (org-roam-node reverse indexed)
     (t reverse)))
  (vertico-multiform-commands
   '(("flyspell-correct-*" grid reverse)
     (org-refile grid reverse indexed)
     (consult-yank-pop indexed)
     (consult-flycheck)
     (consult-lsp-diagnostics)))
  :init
  (defun kb/vertico-multiform-flat-toggle ()
    "Toggle between flat and reverse."
    (interactive)
    (vertico-multiform--display-toggle 'vertico-flat-mode)
    (if vertico-flat-mode
        (vertico-multiform--temporary-mode 'vertico-reverse-mode -1)
      (vertico-multiform--temporary-mode 'vertico-reverse-mode 1)))
  (defun kb/vertico-quick-embark (&optional arg)
    "Embark on candidate using quick keys."
    (interactive)
    (when (vertico-quick-jump)
      (embark-act arg)))

  ;; Workaround for problem with `tramp' hostname completions. This overrides
  ;; the completion style specifically for remote files! See
  ;; https://github.com/minad/vertico#tramp-hostname-completion
  (defun kb/basic-remote-try-completion (string table pred point)
    (and (vertico--remote-p string)
         (completion-basic-try-completion string table pred point)))
  (defun kb/basic-remote-all-completions (string table pred point)
    (and (vertico--remote-p string)
         (completion-basic-all-completions string table pred point)))
  (add-to-list 'completion-styles-alist
               '(basic-remote           ; Name of `completion-style'
                 kb/basic-remote-try-completion kb/basic-remote-all-completions nil))
  :config
  (vertico-mode)
  ;; Extensions
  (vertico-multiform-mode)

  ;; Prefix the current candidate with “» ”. From
  ;; https://github.com/minad/vertico/wiki#prefix-current-candidate-with-arrow
  (advice-add #'vertico--format-candidate :around
                                          (lambda (orig cand prefix suffix index _start)
                                            (setq cand (funcall orig cand prefix suffix index _start))
                                            (concat
                                             (if (= vertico--index index)
                                                 (propertize "» " 'face 'vertico-current)
                                               "  ")
                                             cand))))
#+end_src

** Embark with Consult

#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :bind (:map minibuffer-local-map
           ("M-o"     . embark-act)
           ("C-c C-c" . embark-export)
           ("C-c C-o" . embark-collect)))

  (use-package consult
    :ensure t
    :bind (([remap imenu]                  . consult-imenu)
           ([remap goto-line]              . consult-goto-line)
           ([remap bookmark-jump]          . consult-bookmark)
           ([remap recentf-open-files]     . consult-recent-file)
           ([remap repeat-complex-command] . consult-complex-command)
           ([remap jump-to-register]       . consult-register-load)
           ([remap point-to-register]      . consult-register-store))
    :config
    (with-no-warnings
      (consult-customize consult-ripgrep consult-git-grep consult-grep
                         consult-bookmark
                         consult-recent-file
                         consult-buffer
                         :preview-key nil))

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)
    :custom
    (consult-fontify-preserve nil)
    (consult-async-min-input 2)
    (consult-async-refresh-delay 0.15)
    (consult-async-input-throttle 0.2)
    (consult-async-input-debounce 0.1))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :ensure t
    :after embark consult)
#+end_src

** Orderless
Orderless is an alternative and powerful completion style, that is, it is an alternative to Emacs’s basic candidate-filtering capacities.

#+begin_src emacs-lisp
  (use-package orderless
  :custom
  (completion-styles '(orderless))
  (completion-category-defaults nil)    ; I want to be in control!
  (completion-category-overrides
   '((file (styles basic-remote ; For `tramp' hostname completion with `vertico'
                   orderless))))

  (orderless-component-separator 'orderless-escapable-split-on-space)
  (orderless-matching-styles
   '(orderless-literal
     orderless-prefixes
     orderless-initialism
     orderless-regexp
     ;; orderless-flex
     ;; orderless-strict-leading-initialism
     ;; orderless-strict-initialism
     ;; orderless-strict-full-initialism
     ;; orderless-without-literal          ; Recommended for dispatches instead
     ))
  (orderless-style-dispatchers
   '(prot-orderless-literal-dispatcher
     prot-orderless-strict-initialism-dispatcher
     prot-orderless-flex-dispatcher))
  :init
  (defun orderless--strict-*-initialism (component &optional anchored)
    "Match a COMPONENT as a strict initialism, optionally ANCHORED.
The characters in COMPONENT must occur in the candidate in that
order at the beginning of subsequent words comprised of letters.
Only non-letters can be in between the words that start with the
initials.

If ANCHORED is `start' require that the first initial appear in
the first word of the candidate.  If ANCHORED is `both' require
that the first and last initials appear in the first and last
words of the candidate, respectively."
    (orderless--separated-by
        '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)))
      (cl-loop for char across component collect `(seq word-start ,char))
      (when anchored '(seq (group buffer-start) (zero-or-more (not alpha))))
      (when (eq anchored 'both)
        '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)) eol))))

  (defun orderless-strict-initialism (component)
    "Match a COMPONENT as a strict initialism.
This means the characters in COMPONENT must occur in the
candidate in that order at the beginning of subsequent words
comprised of letters.  Only non-letters can be in between the
words that start with the initials."
    (orderless--strict-*-initialism component))

  (defun prot-orderless-literal-dispatcher (pattern _index _total)
    "Literal style dispatcher using the equals sign as a suffix.
It matches PATTERN _INDEX and _TOTAL according to how Orderless
parses its input."
    (when (string-suffix-p "=" pattern)
      `(orderless-literal . ,(substring pattern 0 -1))))

  (defun prot-orderless-strict-initialism-dispatcher (pattern _index _total)
    "Leading initialism  dispatcher using the comma suffix.
It matches PATTERN _INDEX and _TOTAL according to how Orderless
parses its input."
    (when (string-suffix-p "," pattern)
      `(orderless-strict-initialism . ,(substring pattern 0 -1))))

  (defun prot-orderless-flex-dispatcher (pattern _index _total)
    "Flex  dispatcher using the tilde suffix.
It matches PATTERN _INDEX and _TOTAL according to how Orderless
parses its input."
    (when (string-suffix-p "." pattern)
      `(orderless-flex . ,(substring pattern 0 -1)))))
#+end_src

*** Projectile
Projectile is a project interaction library for Emacs

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :hook (after-init . projectile-mode)
    :bind (:map projectile-mode-map
           ("C-c p" . projectile-command-map))
    :config
    (dolist (dir '("bazel-bin"
                   "bazel-out"
                   "bazel-testlogs"))
      (add-to-list 'projectile-globally-ignored-directories dir))
    :custom
    (projectile-use-git-grep t)
    (projectile-indexing-method 'alien)
    (projectile-kill-buffers-filter 'kill-only-files)
    ;; Ignore uninteresting files. It has no effect when using alien mode.
    (projectile-globally-ignored-files '("TAGS" "tags" ".DS_Store"))
    (projectile-globally-ignored-file-suffixes '(".elc" ".pyc" ".o" ".swp" ".so" ".a"))
    (projectile-ignored-projects `("~/"
                                   "/tmp/"
                                   "/private/tmp/"
                                   ,package-user-dir)))
#+END_SRC


* Developer
** LSP
*** Lsp Mode

#+begin_src emacs-lisp
  ;; lsp-mode
  (use-package lsp-mode
    :ensure t
    :hook (prog-mode . lsp-deferred)
    :bind (:map lsp-mode-map
                ("C-c f" . lsp-format-region)
                ("C-c d" . lsp-describe-thing-at-point)
                ("C-c a" . lsp-execute-code-action)
                ("C-c r" . lsp-rename))
    :config (with-no-warnings
            (lsp-enable-which-key-integration t))
    :custom
    (lsp-keymap-prefix "C-c l")
    (lsp-enable-links nil)                    ;; no clickable links
    (lsp-enable-folding nil)                  ;; use `hideshow' instead
    (lsp-enable-snippet t)                    ;; no snippets, it requires `yasnippet'
    (lsp-enable-file-watchers nil)            ;; performance matters
    (lsp-enable-text-document-color nil)      ;; as above
    (lsp-enable-symbol-highlighting t)        ;; as above
    (lsp-enable-on-type-formatting nil)       ;; as above
    (lsp-semantic-tokens-enable nil)          ;; optional
    (lsp-semantic-tokens-apply-modifiers nil) ;; don't override token faces
    (lsp-headerline-breadcrumb-enable nil)    ;; keep headline clean
    (lsp-modeline-code-actions-enable nil)    ;; keep modeline clean
    (lsp-modeline-diagnostics-enable t)       ;; as above
    (lsp-log-io nil)                          ;; debug only
    (lsp-auto-guess-root t)                   ;; Yes, I'm using projectile
    (lsp-completion-provider :none)           ;; don't add `company-capf' to `company-backends'
    (lsp-keep-workspace-alive nil)            ;; auto kill lsp server
    (lsp-eldoc-enable-hover nil)              ;; disable eldoc hover
    ;; 指定 flycheck 使用 clippy
    ;; (lsp-rust-analyzer-cargo-watch-command "clippy")
    (lsp-rust-analyzer-server-display-inlay-hints t)
    (lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial")
    (lsp-rust-analyzer-display-chaining-hints t)
    (lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil)
    (lsp-rust-analyzer-display-closure-return-type-hints t)
    (lsp-rust-analyzer-display-parameter-hints nil)
    (lsp-rust-analyzer-display-reborrow-hints nil)

    :config
    (add-hook 'lsp-mode-hook 'lsp-ui-mode))
#+end_src

*** Eglot

#+begin_src emacs-lisp
  (use-package eglot
    :disabled
    :hook (prog-mode . eglot-ensure)
    :bind (:map eglot-mode-map
                ("C-c f" . eglot-format)
                ("C-c d" . eldoc-doc-buffer)
                ("C-c a" . eglot-code-actions)
                ("C-c r" . eglot-rename)
                ("C-c l" . eglot-command-map))
    :config
    (defvar-keymap eglot-command-map
      :prefix 'eglot-command-map
      ;; workspaces
      "w q" #'eglot-shutdown
      "w r" #'eglot-reconnect
      "w s" #'eglot
      "w d" #'eglot-show-workspace-configuration

      ;; formatting
      "= =" #'eglot-format-buffer
      "= r" #'eglot-format

      ;; goto
      "g a" #'xref-find-apropos
      "g d" #'eglot-find-declaration
      "g g" #'xref-find-definitions
      "g i" #'eglot-find-implementation
      "g r" #'xref-find-references
      "g t" #'eglot-find-typeDefinition

      ;; actions
      "a q" #'eglot-code-action-quickfix
      "a r" #'eglot-code-action-rewrite
      "a i" #'eglot-code-action-inline
      "a e" #'eglot-code-action-extract
      "a o" #'eglot-code-action-organize-imports)
    :custom
    (eglot-sync-connect 0)
    (eglot-autoshutdown t)
    (eglot-extend-to-xref t)
    (eglot-events-buffer-size 0)
    (eglot-ignored-server-capabilities '(:documentLinkProvider
                                         :documentOnTypeFormattingProvider)))
#+end_src

*** LSP Ui
#+begin_src emacs-lisp
  (use-package lsp-ui
    :ensure
    :commands lsp-ui-mode
    :custom (lsp-ui-peek-always-show t)
            (lsp-ui-sideline-show-hover nil)
            (lsp-ui-sideline-enable nil)
            (lsp-ui-doc-enable nil))
#+end_src

** Language
*** Rust
**** Rustic
rustic = basic rust-mode + additions

#+begin_src emacs-lisp
  (use-package rustic
    :ensure
    :bind (:map rustic-mode-map
                ("M-j" . lsp-ui-imenu)
                ("M-?" . lsp-find-references)
                ("C-c C-c l" . flycheck-list-errors)
                ("C-c C-c a" . lsp-execute-code-action)
                ("C-c C-c r" . lsp-rename)
                ("C-c C-c q" . lsp-workspace-restart)
                ("C-c C-c Q" . lsp-workspace-shutdown)
                ("C-c C-c s" . lsp-rust-analyzer-status)
                ("C-c C-c e" . lsp-rust-analyzer-expand-macro)
                ("C-c C-c d" . dap-hydra)
                ("C-c C-c h" . lsp-ui-doc-glance))
    :config (push 'rustic-clippy flycheck-checkers)
            (setq rustic-format-on-save t)
    ;; uncomment for less flashiness
    ;; (setq lsp-eldoc-hook nil)
    ;; (setq lsp-enable-symbol-highlighting nil)
    ;; (setq lsp-signature-auto-activate nil)
    :custom (rustic-lsp-setup-p nil)
            (rustic-analyzer-command '("~/.local/share/cargo/bin/rust-analyzer"))
            (rustic-flycheck-clippy-params "--message-format=json -Zunstable-options")
            (rustic-rustfmt-args "+nightly")
            (rustic-rustfmt-config-alist '((hard_tabs . t) (skip_children . nil)))
    
    (add-hook 'rustic-mode-hook 'kv/rustic-mode-hook))

  (defun kv/rustic-mode-hook ()
    ;; so that run C-c C-c C-r works without having to confirm, but don't try to
    ;; save rust buffers that are not file visiting. Once
    ;; https://github.com/brotzeit/rustic/issues/253 has been resolved this should
    ;; no longer be necessary.
    (when buffer-file-name
      (setq-local buffer-save-without-query t))
    (add-hook 'before-save-hook 'lsp-format-buffer nil t))
#+end_src

**** Rust Playground
Create / cleanup rust scratch projects quickly

#+begin_src emacs-lisp
  (use-package rust-playground :ensure)
#+end_src

**** Toml
Cargo.toml and other config files
#+begin_src emacs-lisp
  (use-package toml-mode :ensure)
#+end_src

*** C/C++

#+begin_src emacs-lisp
#+end_src

*** Yaml

#+begin_src emacs-lisp
  ;; Config files mode
  (use-package yaml-mode
    :ensure t
    :mode ("\\.ya?ml\\'" . yaml-mode))
#+end_src

** Flycheck

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :hook (prog-mode . flycheck-mode)
    :custom
    (flycheck-temp-prefix ".flycheck")
    (flycheck-check-syntax-automatically '(save mode-enabled))
    (flycheck-emacs-lisp-load-path 'inherit)
    (flycheck-indication-mode 'right-fringe))
#+end_src

*** Flycheck Extensions

#+begin_src emacs-lisp
  ;; inline
  (use-package flycheck-inline)
  (with-eval-after-load 'flycheck
    (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))
  ;; for rust
  (use-package flycheck-rust
    :init
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+end_src

** Magit

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :hook (git-commit-setup . git-commit-turn-on-flyspell)
    :bind (("C-x g"   . magit-status)
           ("C-x M-g" . magit-dispatch)
           ("C-c M-g" . magit-file-dispatch))
    :custom
    (magit-diff-refine-hunk t)
    (magit-diff-paint-whitespace nil)
    (magit-ediff-dwim-show-on-hunks t))

  ;; NOTE: `diff-hl' depends on `vc'
  (use-package vc
    :ensure nil
    :custom
    (vc-follow-symlinks t)
    (vc-allow-async-revert t)
    (vc-handled-backends '(Git)))

  ;; Highlight uncommitted changes using VC
  (use-package diff-hl
    :ensure t
    :hook ((after-init         . global-diff-hl-mode)
           (dired-mode         . diff-hl-dired-mode-unless-remote)
           (magit-pre-refresh  . diff-hl-magit-pre-refresh)
           (magit-post-refresh . diff-hl-magit-post-refresh))
    :config
    ;; When Emacs runs in terminal, show the indicators in margin instead.
    (unless (display-graphic-p)
      (diff-hl-margin-mode)))

  ;; Visual diff interface
  (use-package ediff
    :ensure nil
    ;; Restore window config after quitting ediff
    :hook ((ediff-before-setup . ediff-save-window-conf)
           (ediff-quit         . ediff-restore-window-conf))
    :config
    (defvar local-ediff-saved-window-conf nil)

    (defun ediff-save-window-conf ()
      (setq local-ediff-saved-window-conf (current-window-configuration)))

    (defun ediff-restore-window-conf ()
      (when (window-configuration-p local-ediff-saved-window-conf)
        (set-window-configuration local-ediff-saved-window-conf)))
    :custom
    (ediff-highlight-all-diffs t)
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    (ediff-split-window-function 'split-window-horizontally)
    (ediff-merge-split-window-function 'split-window-horizontally))

  ;; Setup gitignore mode
  (use-package conf-mode
    :ensure nil
    :mode (("\\.gitignore\\'"     . conf-unix-mode)
           ("\\.gitconfig\\'"     . conf-unix-mode)
           ("\\.gitattributes\\'" . conf-unix-mode)))
#+end_src



